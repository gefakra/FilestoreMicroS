# FileStoreService
## микросевис для хранения файлов (в больших количествах) на ASP.NET Core
<img width="1024" height="1536" alt="0" src="https://github.com/user-attachments/assets/22376a54-de4b-4ec4-ac20-79d260ffb32c" />
- - - 
в реализации включено -
  вычисление SHA256, GZip-сжатие;
  дедупликация по хэшу;
  добавление/удаление владельцев;
  очистка «осиротевших» файлов.  
--
- 4 REST-эндпоинта:
[POST] /api/files?owner={guid} — загрузка и добавление владельца;
[GET] /api/files/{hash} — скачать файл;
[GET] /api/files/{hash}/exists — проверить наличие (204/404);
[DELETE] /api/files/owner/{guid} — удалить все файлы владельца;
[DELETE] /api/files/{hash}/owner/{guid} — удалить конкретный файл у владельца.

-Swagger/OpenAPI

###Чистая архитектура:
✅ Асинхронно и потокобезопасно, общение через асинхронные каналы (Channel) — не блокирует поток;
✅ Возможность масштабировать:
  1.Можно масштабировать отдельные стадии (например, 4 компрессора, 1 хешер);
  2.отдельный Worker для Writer или Compressor
✅ Минимум памяти (bounded channels);
✅ Cancellation на уровне конвейера;
✅ Управляем памятью через ArrayPool<byte>;
✅ Работает на больших объёмах (10–100 ГБ) без переполнения памяти.

###Конвейерный подход - Использована архитектура Pipeline где каждый этап это независимая стадия обработки (SRP на уровне потоков);
4 этапа -
 Reader	- Читает из входного Stream, нарезает куски и пишет в Channel<ReadOnlyMemory<byte>>
 Hasher - Вычисляет SHA256 на лету, передаёт дальше
 Compressor - Получает блоки, пишет в GZipStream, можно распараллелить
 Writer - Сохраняет .gz файл на диск или S3/MinIO
 ##Cancellation - Если клиент оборвал соединение, вызывается Cancel() — Dataflow отменяет все задачи

 ##ArrayPool и контроль буфера
 ArrayPool<byte> — арендует большие блоки памяти из пула, не выделяя новые byte[] через GC.
 GC-нагрузка - Минимизируется: нет новых массивов, только переиспользуемые блоки
 Канал хранит только ссылки на буферы, а не сами данные.
 Даже если ты качаешь 10 ГБ файл — в RAM будет ≤ ~512 KB активных данных.
 
